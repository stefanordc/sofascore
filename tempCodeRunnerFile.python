import json, datetime, random, time, re, logging, sys, collections, os
from typing import Dict, List, Tuple, Any
import pandas as pd
import pymysql
import requests
import backoff
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager
from selenium.common.exceptions import TimeoutException, WebDriverException
import substituicoes_clubes

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CONFIGURAÃ‡Ã•ES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #
temporada = "2025"
MAX_MATCHES_PER_DRIVER = 30
HEADLESS = True

# ------------------------- PROXY (SEM AUTENTICAÃ‡ÃƒO) ---------------------- #
USAR_PROXY = True
proxy_user = ""
proxy_pass = ""
proxy_host = "200.174.198.86"
proxy_port = "8888"

# falhas consecutivas do proxy (requests/selenium) para desligar automÃ¡tico
PROXY_FAIL_STRIKES = 0
PROXY_FAIL_LIMIT = 2

# ----------------------------- LISTA DE URLS ----------------------------- #
urls: List[str] = [
    'https://www.sofascore.com/pt/football/match/fluminense-bahia/fOslO#id:14415849',
    'https://www.sofascore.com/pt/football/match/athletico-corinthians/hOsrO#id:14415851',
    'https://www.sofascore.com/pt/football/match/millonarios-deportivo-pasto/nxcsrxc#id:14216309',
    'https://www.sofascore.com/pt/football/match/vejgaard-bk-esbjerg-fb/MAsaYPi#id:14419736',
    'https://www.sofascore.com/pt/football/match/deportivo-cuenca-aucas/Zecsbfc#id:14595513',
    'https://www.sofascore.com/pt/football/match/temp-barnaul-znamya-truda-orekhovo-zuevo/weFseLdd#id:14532760',
    'https://www.sofascore.com/pt/football/match/kosmos-dolgoprudnyi-veles-moscow/GEdcsbhcd#id:14532752',
    'https://www.sofascore.com/pt/football/match/zenit-penza-volgar-astrakhan/wNnsEdF#id:14532756',
    'https://www.sofascore.com/pt/football/match/psk-dinskaya-dinamo-stavropol/qwrbsgXFi#id:14532757',
    'https://www.sofascore.com/pt/football/match/volna-kovernino-fc-tyumen/heFsHdBc#id:14532761',
    'https://www.sofascore.com/pt/football/match/luki-energia-velikie-luki-fc-cherepovets/NlbcsyAdc#id:14532754',
    'https://www.sofascore.com/pt/football/match/kuban-holding-pavlovskaya-mashuk-kmv-pyatigorsk/vadsdlpc#id:14532755',
    'https://www.sofascore.com/pt/football/match/dinamo-vologda-tekstilshchik-ivanovo/DadsFHcd#id:14532759',
    'https://www.sofascore.com/pt/football/match/fankom-kirov-khimik-dzerzhinsk/neFsjaqd#id:14532750',
    'https://www.sofascore.com/pt/football/match/kristall-mezt-borisoglebsk-spartak-tambov/TdFsdEdd#id:14532753'
]

# ------------- tabelÃ£o de substituiÃ§Ãµes de campeonatos ------------- #
substituicoes_campeonatos = {
    'BrasileirÃ£o Betano': 'Brasileiro',
    'Copa Betano do Brasil': 'Copa do Brasil',
    'FIFA Club World Cup': 'Copa do Mundo de Clubes',
    'Brasileiro SÃ©rie B': 'Brasileiro - SÃ©rie B',
    'CONMEBOL Libertadores': 'Libertadores',
    'CONMEBOL Sudamericana': 'Sul-Americana',
    'Mineiro MÃ³dulo I': 'Mineiro',
    'Paulista SÃ©rie A1': 'Paulista',
    'Carioca SÃ©rie A â€“ TaÃ§a Guanabara': 'Carioca',
    'GaÃºcho - Mata-mata': 'GaÃºcho',
    'Baiano, SÃ©rie A': 'Baiano',
    'Cearense, SÃ©rie A': 'Cearense',
    'CONMEBOL Recopa': 'Recopa Sul-Americana',
    'Mineiro MÃ³dulo I - TrofÃ©u InconfidÃªncia': 'Mineiro',
    'Goiano, 1Âª DivisÃ£o': 'Goiano',
    'UEFA Europa League': 'Liga Europa',
    'UEFA Champions League': 'Liga dos CampeÃµes',
    'UEFA Conference League': 'Conference League',
    'UEFA Europa Conference League': 'Conference League',
    'NM Cup': 'Copa da Noruega',
    'Primera A': 'Colombiano',
    'Svenska Cupen': 'Copa da SuÃ©cia',
    'Liga de Primera': 'Chileno',
    'Liga AUF Uruguaya': 'Uruguaio',
    'J1 League': 'JaponÃªs',
    'Primera Division': 'Venezuelano',
    'Copa Venezuela': 'Copa da Venezuela',
    'DivisiÃ³n Profesional': 'Boliviano',
    'Copa Division Profesional': 'Copa da BolÃ­via',
    'Super Cup': 'Supercopa',
    'Copa Colombia': 'Copa da Colombia',
    'Liga 1': 'Peruano',
    'Premier Division': 'IrlandÃªs',
    'LigaPro Serie A': 'Equatoriano',
    'Eliteserien': 'NorueguÃªs',
    'Copa Argentina': 'Copa da Argentina',
    'Gaucho': 'GaÃºcho',
    'Allsvenskan': 'Sueco',
    'Supercopa Internacional': 'Supercopa da Argentina',
    'Liga Profesional de FÃºtbol': 'Argentino',
    'Copa Chile': 'Copa do Chile',
    'Copa Ecuador': 'Copa do Equador',
    'Supercopa': 'Supercopa do Equador',
    'Leinster Senior Cup': 'Copa da Liga da Irlanda',
    'FAI Presidents Cup': 'Supercopa da Irlanda',
    'Emperor Cup': 'Copa do Imperador',
    'J. League Cup': 'Copa da Liga do JapÃ£o',
    'FAI Cup': 'Copa da Irlanda',
    'DivisiÃ³n de Honor': 'Paraguaio',
    'Supercopa Uruguaya': 'Supercopa do Uruguai',
    'Supercopa Venezuela': 'Supercopa da Venezuela',
    'Community Shield': 'Supercopa da Inglaterra',
    'FA Cup': 'Copa da Inglaterra',
    'EFL Cup': 'Copa da Liga Inglesa',
    'LaLiga': 'La Liga',
    'Mineiro MÃ³dulo I - ClassificaÃ§Ã£o contra o rebaixamento': 'Mineiro',
    'Carioca SÃ©rie A â€“ Mata-mata': 'Carioca',
    'Carioca - TaÃ§a Rio': 'Carioca',
    'Carioca - Semifinais': 'Carioca',
    'Carioca - ClassificaÃ§Ã£o preliminar': 'Carioca',
    'Carioca - ClassificaÃ§Ã£o contra o rebaixamento': 'Carioca',
    'Carioca - Mata-mata contra o rebaixamento': 'Carioca',
    'Carioca - Mata-mata da TaÃ§a Guanabara': 'Carioca',
    'GaÃºcho - Final': 'GaÃºcho',
    'GaÃºcho 2Âª fase': 'GaÃºcho',
    'Pernambucano - Luta contra o rebaixamento': 'Pernambucano',
    'Cearense - Luta contra o rebaixamento': 'Cearense',
    'Goiano - Grupo B': 'Goiano',
    'Goiano - Grupo A': 'Goiano',
    'Supercopa de EspaÃ±a': 'Supercopa da Espanha',
    'Copa del Rey': 'Copa do Rei',
    'Coppa Italia': 'Copa da ItÃ¡lia',
    'Supercoppa Italiana': 'Supercopa da ItÃ¡lia',
    'DFL Supercup': 'Supercopa da Alemanha',
    'Supercup': 'Supercopa da Alemanha',
    'DFB Pokal': 'Copa da Alemanha',
    'TrophÃ©e des Champions': 'Supercopa da FranÃ§a',
    'Coupe de France': 'Copa da FranÃ§a',
    'Liga Portugal Betclic': 'PortuguÃªs',
    'TaÃ§a de Portugal': 'Copa de Portugal',
    'League Cup': 'Copa da Liga Portuguesa',
    'Johan Cruijff Schaal': 'Supercopa da Holanda',
    'KNVB beker': 'Copa da Holanda',
    'Ukraine Cup': 'Copa da UcrÃ¢nia',
    'Trendyol SÃ¼per Lig': 'Turco',
    'Super Kupa': 'Supercopa da Turquia',
    'Turkiye Kupasi': 'Copa da Turquia',
    'Stoiximan Super League': 'Grego',
    'Greek Football Cup': 'Copa da GrÃ©cia',
    'Saudi Pro League': 'Saudita',
    "King's Cup": 'Copa da ArÃ¡bia',
    'UEFA Super Cup': 'Supercopa da Europa',
    'Liga dos CampeÃµes da UEFA': 'Liga dos CampeÃµes',
    'AFC Champions League Elite': 'Liga dos CampeÃµes da Ãsia',
    'CONCACAF Champions Cup': 'Copa dos CampeÃµes da Concacaf',
    'Liga MX': 'Mexicano',
    'Supercopa Liga MX': 'Supercopa da Liga Mexicana',
    'Russian Cup': 'Copa da RÃºssia',
    'Danish Superliga': 'DinamarquÃªs',
    'Oddset Pokalen': 'Copa da Dinamarca',
    'Pro League': 'Belga',
    'Beker van Belgie': 'Copa da BÃ©lgica',
    'Primera LPF': 'Argentino',
    'World Cup QualificaÃ§Ã£o': 'EliminatÃ³rias',
    'Int. Friendly Games': 'Amistoso',
    'CONMEBOL Copa AmÃ©rica': 'Copa AmÃ©rica',
    'UEFA Nations League': 'Nations League',
    'Euro': 'Eurocopa',
    'World Cup Qual. UEFA L': 'EliminatÃ³rias',
    'World Cup Qual. UEFA K': 'EliminatÃ³rias',
    'World Cup Qual. UEFA J': 'EliminatÃ³rias',
    'World Cup Qual. UEFA H': 'EliminatÃ³rias',
    'World Cup Qual. UEFA A': 'EliminatÃ³rias',
    'World Cup Qual. UEFA G': 'EliminatÃ³rias',
    'World Cup Qual. UEFA E': 'EliminatÃ³rias',
    'World Cup Qual. UEFA B': 'EliminatÃ³rias',
    'World Cup Qual. UEFA C': 'EliminatÃ³rias',
    'World Cup Qual. UEFA D': 'EliminatÃ³rias',
    'World Cup Qual. UEFA F': 'EliminatÃ³rias',
    'World Cup Qual. UEFA I': 'EliminatÃ³rias',
    'FIFA World Cup': 'Copa do Mundo',
    'World Cup Qualification': 'EliminatÃ³rias',
    'CONCACAF Gold Cup': 'Copa Ouro',
    'FIFA Intercontinental Cup': 'Mundial de Clubes',
    'Primera DivisiÃ³n': 'Paraguaio',
    'Liga Profesional': 'Argentino',
    'Russian Cup Regions Path': 'Copa da RÃºssia',
    'Copa de la Liga': 'Copa da Liga Argentina',
    'VriendenLoterij Eredivisie': 'Eredivisie',
    'Mineiro MÃ³dulo I - Playoffs': 'Mineiro',
    'Paulista SÃ©rie A1 - Playoffs': 'Paulista',
    'Paulista SÃ©rie A1 - TrofÃ©u do Interior - Playoffs': 'Paulista',
    'Cearense - 2Âª fase': 'Cearense',
    'Carioca â€“ TaÃ§a Rio': 'Carioca',
    'Copa Uruguay': 'Copa do Uruguai',
    'BrasileirÃ£o SÃ©rie B': 'Brasileiro - SÃ©rie B',
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LOGGING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s  %(levelname)-8s %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)]
)
log = logging.getLogger("sofascore")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ sessÃ£o HTTP (ignora proxies do ambiente) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #
session: requests.Session | None = None

def rebuild_session():
    """Cria/recria a sessÃ£o de requests, ignorando HTTP(S)_PROXY do ambiente.
    Injeta proxy apenas se USAR_PROXY=True."""
    global session
    try:
        if session:
            session.close()
    except Exception:
        pass
    session = requests.Session()
    session.trust_env = False  # <â€” ignora variÃ¡veis de ambiente de proxy
    session.headers.update({
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
        "Accept": "application/json, text/plain, */*",
        "Origin": "https://www.sofascore.com",
        "Referer": "https://www.sofascore.com/",
        "X-Requested-With": "XMLHttpRequest",
        "Accept-Language": "pt-BR,pt;q=0.9,en;q=0.8",
    })
    if USAR_PROXY and proxy_host and proxy_port:
        proxy_url = f"http://{proxy_host}:{proxy_port}"
        session.proxies.update({"http": proxy_url, "https": proxy_url})
        log.info("ğŸŒ Proxy requests habilitado: %s", proxy_url)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ helpers de proxy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #
def desativar_proxy_instavel(motivo: str):
    """Desliga proxy (requests + selenium) e reinicia o driver."""
    global USAR_PROXY, PROXY_FAIL_STRIKES, session, driver, matches_done_with_this_driver
    if not USAR_PROXY:
        return
    USAR_PROXY = False
    PROXY_FAIL_STRIKES = 0
    rebuild_session()  # garante que o requests pare de usar proxy do ambiente
    log.warning("ğŸ›‘ Proxy desativado automaticamente (%s). Reiniciando Chrome sem proxy...", motivo)
    try:
        driver.quit()
    except Exception:
        pass
    driver = criar_driver()  # respeita USAR_PROXY=False
    matches_done_with_this_driver = 0

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CHROME DRIVER HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #
def criar_driver() -> webdriver.Chrome:
    opts = Options()
    if HEADLESS:
        opts.add_argument("--headless=new")
    opts.add_argument("--disable-gpu")
    opts.add_argument("--disable-webgl")
    opts.add_argument("--disable-3d-apis")
    opts.add_argument("--no-sandbox")
    opts.add_argument("--disable-extensions")
    opts.add_argument("--window-size=1920,1080")
    # endurecimentos anti-bloqueio
    opts.add_experimental_option("excludeSwitches", ["enable-automation", "enable-logging"])
    opts.add_experimental_option("useAutomationExtension", False)
    opts.add_argument("--disable-blink-features=AutomationControlled")
    # carregar DOM mais rÃ¡pido
    opts.page_load_strategy = 'eager'
    # reduzir carga (imagens off)
    opts.add_experimental_option("prefs", {
        "profile.managed_default_content_settings.images": 2,
        "profile.default_content_setting_values.notifications": 2
    })
    # >>> PROXY NO CHROME (cobre http e https)
    if USAR_PROXY and proxy_host and proxy_port:
        proxy_spec = f"http={proxy_host}:{proxy_port};https={proxy_host}:{proxy_port}"
        opts.add_argument(f"--proxy-server={proxy_spec}")
        log.info("ğŸŒ Proxy Chrome habilitado: %s", proxy_spec)

    drv = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=opts)
    drv.set_page_load_timeout(30)
    drv.set_script_timeout(20)
    # remove navigator.webdriver
    try:
        drv.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", {
            "source": "Object.defineProperty(navigator, 'webdriver', {get: () => undefined})"
        })
    except Exception:
        pass
    return drv

# cria sessÃ£o requests e driver
rebuild_session()
driver = criar_driver()
matches_done_with_this_driver = 0

def restart_driver():
    global driver, matches_done_with_this_driver
    try:
        driver.quit()
    except Exception:
        pass
    driver = criar_driver()
    matches_done_with_this_driver = 0
    log.info("â™»ï¸  ChromeDriver reiniciado")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ BASE DE DADOS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #
conn = pymysql.connect(host="localhost", user="admin", password="1234",
                       database="bet_dados", charset="utf8mb4")
cursor = conn.cursor()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ UTIL: BUSCAR 'event' NO DOM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #
def _deep_find(d: Any, key: str) -> Any:
    if isinstance(d, dict):
        if key in d:
            return d[key]
        for v in d.values():
            r = _deep_find(v, key)
            if r is not None:
                return r
    elif isinstance(d, list):
        for item in d:
            r = _deep_find(item, key)
            if r is not None:
                return r
    return None

def extract_event_from_dom(drv: webdriver.Chrome, id_jogo: str) -> Dict | None:
    try:
        script_tag = drv.find_element(By.CSS_SELECTOR, "script#__NEXT_DATA__")
    except Exception:
        return None
    try:
        data = json.loads(script_tag.get_attribute("innerHTML"))
    except json.JSONDecodeError:
        return None
    evt = _deep_find(data, "event")
    if isinstance(evt, dict) and str(evt.get("id")) == str(id_jogo):
        return evt
    return None

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ REQUISIÃ‡ÃƒO Ã€ API COM FALLBACKS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #
def _selenium_api_json(url_api: str) -> Dict:
    """Abre a URL da API no navegador e tenta capturar o JSON da pÃ¡gina."""
    global PROXY_FAIL_STRIKES
    try:
        driver.get(url_api)
    except WebDriverException as e:
        # erros tÃ­picos de proxy/RESET contam strike
        if "ERR_CONNECTION_RESET" in str(e):
            PROXY_FAIL_STRIKES += 1
            if USAR_PROXY and PROXY_FAIL_STRIKES >= PROXY_FAIL_LIMIT:
                desativar_proxy_instavel("ERR_CONNECTION_RESET no Selenium")
        raise

    try:
        # 1) tentar <pre>
        try:
            el = WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.TAG_NAME, "pre")))
            txt = el.text.strip()
            if txt:
                return json.loads(txt)
        except TimeoutException:
            pass

        # 2) tentar body.innerText
        try:
            txt = driver.find_element(By.TAG_NAME, "body").text.strip()
            if txt.startswith("{") or txt.startswith("["):
                return json.loads(txt)
        except Exception:
            pass

        # 3) tentar page_source
        src = driver.page_source
        m = re.search(r"<pre[^>]*>(.*?)</pre>", src, flags=re.DOTALL | re.IGNORECASE)
        if m:
            raw = re.sub(r"<[^>]+>", "", m.group(1)).strip()
            return json.loads(raw)

        raise ValueError("NÃ£o consegui capturar JSON via Selenium")
    except TimeoutException:
        PROXY_FAIL_STRIKES += 1
        if USAR_PROXY and PROXY_FAIL_STRIKES >= PROXY_FAIL_LIMIT:
            desativar_proxy_instavel("Timeout ao ler JSON via Selenium")
        raise
    except json.JSONDecodeError as e:
        raise ValueError(f"JSON invÃ¡lido na pÃ¡gina da API: {e}")

@backoff.on_exception(
    backoff.expo,
    (requests.exceptions.RequestException, ValueError, TimeoutException, WebDriverException),
    factor=2, max_time=90
)
def obter_dados_api(url_api: str) -> Dict:
    """Tenta API com requests; se falhar por qualquer motivo, usa Selenium."""
    global PROXY_FAIL_STRIKES
    # sincroniza cookies (ajuda no 403)
    try:
        session.cookies.clear()
        for c in driver.get_cookies():
            session.cookies.set(c["name"], c["value"])
    except Exception:
        pass

    try:
        resp = session.get(url_api, timeout=20)
    except requests.exceptions.RequestException as e:
        # Contabiliza falha de proxy e tenta Selenium imediatamente
        PROXY_FAIL_STRIKES += 1
        if USAR_PROXY and PROXY_FAIL_STRIKES >= PROXY_FAIL_LIMIT:
            desativar_proxy_instavel(f"Falhas consecutivas no requests: {type(e).__name__}")
        return _selenium_api_json(url_api)

    if resp.status_code == 403:
        return _selenium_api_json(url_api)

    try:
        resp.raise_for_status()
        return resp.json()
    except Exception:
        # conteÃºdo nÃ£o-JSON, 5xx etc â†’ Selenium
        return _selenium_api_json(url_api)

def safe_get_event(id_jogo: str) -> Dict:
    for tentativa in range(4):
        try:
            data = obter_dados_api(f"https://api.sofascore.com/api/v1/event/{id_jogo}")
            if "event" in data:
                return data["event"]
        except Exception as e:
            log.debug("API falhou (%s) â€“ tentando DOM", e)

        dom_evt = extract_event_from_dom(driver, id_jogo)
        if dom_evt:
            return dom_evt

        log.warning("Tentativa %d â€“ nÃ£o consegui 'event'", tentativa + 1)
        time.sleep(4 + random.random() * 2)

    # Ãºltima cartada: Selenium direto na rota
    try:
        return _selenium_api_json(f"https://api.sofascore.com/api/v1/event/{id_jogo}")["event"]
    except Exception:
        pass
    raise RuntimeError(f"NÃ£o consegui 'event' para {id_jogo}")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FUNÃ‡Ã•ES DE EXTRAÃ‡ÃƒO (Selenium) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #
def get_region_text(drv: webdriver.Chrome) -> str:
    for s in drv.find_elements(By.CSS_SELECTOR, "script[type='application/ld+json']"):
        try:
            d = json.loads(s.get_attribute("innerHTML"))
            if isinstance(d, dict) and d.get("@type") == "BreadcrumbList":
                return d["itemListElement"][1]["name"]
        except Exception:
            pass
    anchors = drv.find_elements(By.CSS_SELECTOR, "a[href^='/pt/futebol/']:not([href='/pt/futebol/'])")
    return anchors[0].text.strip() if anchors else "Desconhecido"

def get_odds(drv: webdriver.Chrome, max_scrolls: int = 6, wait_each: float = 0.7) -> Tuple[str | None, str | None, str | None]:
    X_RES_FINAL = ("//span[translate(.,'RESULTADO FINAL','resultado final')='resultado final']"
                   "/ancestor::div[contains(@class,'bg_surface')]")
    try:
        for _ in range(max_scrolls):
            try:
                bloco = WebDriverWait(drv, 5).until(EC.presence_of_element_located((By.XPATH, X_RES_FINAL)))
                links = bloco.find_elements(
                    By.XPATH,
                    ".//a[.//span[@class='textStyle_assistive.default c_neutrals.nLv3 w_100% ta_center trunc_true']]")
                mapa = {}
                for l in links:
                    rot = l.find_element(By.XPATH, ".//span[contains(@class,'textStyle_assistive.default')]").text.strip()
                    val = l.find_element(By.XPATH, ".//span[contains(@class,'textStyle_display.micro')]").text.strip()
                    mapa[rot] = val
                return mapa.get("1"), mapa.get("X"), mapa.get("2")
            except Exception:
                try:
                    drv.execute_script("window.scrollBy(0, 1000);")
                except Exception:
                    pass
                time.sleep(wait_each)
    except (TimeoutException, WebDriverException) as e:
        logging.debug("get_odds travou: %s", e)
    return None, None, None

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ AUXILIARES BD (substituir + estatÃ­sticas) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #
def substituir_campeonato(n: str) -> str:
    return substituicoes_campeonatos.get(n.strip(), n.strip())

def inserir_estatisticas(id_jogo: str, home: str, away: str,
                         periodo: str, tabela: str, stats: dict):
    cursor.execute(f"SELECT 1 FROM {tabela} WHERE id_jogo=%s LIMIT 1", (id_jogo,))
    if cursor.fetchone():
        return
    grp = next((g for g in stats.get("statistics", []) if g["period"] == periodo), None)
    if not grp or not grp.get("groups"):
        return
    df = pd.DataFrame([{"id_jogo": id_jogo, "clube": home},
                       {"id_jogo": id_jogo, "clube": away}])
    df["temporada"] = temporada
    for g in grp["groups"]:
        for it in g.get("statisticsItems", []):
            k = it["name"].lower().replace(" ", "_").replace("(", "").replace(")", "")
            df.loc[0, k] = it.get("home", 0)
            df.loc[1, k] = it.get("away", 0)

    cursor.execute(f"SHOW COLUMNS FROM {tabela}")
    cols_db = {c[0] for c in cursor.fetchall()}
    for col in cols_db:
        if col not in df.columns and col != "id":
            df[col] = datetime.datetime.now() if col == "cadastrado_em" else 0
    df = df[[c for c in df.columns if c in cols_db]]
    cols_sql = ",".join(f"`{c}`" for c in df.columns)
    vals_sql = ",".join(["%s"] * len(df.columns))
    cursor.executemany(f"INSERT INTO {tabela} ({cols_sql}) VALUES ({vals_sql})",
                       df.fillna(0).values.tolist())
    conn.commit()
    log.info("âœ…  EstatÃ­sticas inseridas: %s", tabela)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ TEMPO DOS GOLS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #
def _disp(x):
    return x.get("display", 0) if isinstance(x, dict) else (x or 0)

def inserir_tempo_gols(id_jogo: str, campeonato_padronizado: str, home: str, away: str):
    cursor.execute("SELECT 1 FROM tempo_gols WHERE id_jogo=%s LIMIT 1", (id_jogo,))
    if cursor.fetchone():
        log.info("â„¹ï¸  tempo_gols jÃ¡ possui id_jogo=%s â€“ nada a fazer.", id_jogo)
        return

    data = obter_dados_api(f"https://api.sofascore.com/api/v1/event/{id_jogo}/incidents")
    incs = data.get("incidents", []) or []

    rows = []
    for inc in incs:
        if inc.get("incidentType") != "goal":
            continue

        home_s = _disp(inc.get("homeScore"))
        away_s = _disp(inc.get("awayScore"))

        actions = inc.get("footballPassingNetworkAction") or [inc]
        for ac in actions:
            tipo = ac.get("eventType", inc.get("incidentType"))
            if tipo != "goal":
                continue
            is_home = ac.get("isHome", inc.get("isHome"))
            minutos = ac.get("time", inc.get("time"))
            forma = ac.get("bodyPart", inc.get("bodyPart"))
            clube_gol = home if is_home else away

            rows.append({
                "id_jogo": id_jogo,
                "temporada": temporada,
                "campeonato": campeonato_padronizado,
                "clube_gol": clube_gol,
                "minutos": int(minutos or 0),
                "forma_gol": forma or "",
                "placar": f"{home_s}-{away_s}",
            })
            break

    if not rows:
        log.info("âš ï¸  Sem gols (provÃ¡vel 0x0) â€“ nÃ£o inserido em tempo_gols.")
        return

    df = pd.DataFrame(rows)
    cursor.execute("SHOW COLUMNS FROM tempo_gols")
    cols_db = [c[0] for c in cursor.fetchall()]
    if "cadastrado_em" in cols_db and "cadastrado_em" not in df.columns:
        df["cadastrado_em"] = datetime.datetime.now()

    keep = [c for c in ["id_jogo","temporada","campeonato","clube_gol","minutos","forma_gol","placar","cadastrado_em"] if c in cols_db]
    df = df[keep]

    cols_sql = ",".join(f"`{c}`" for c in df.columns)
    vals_sql = ",".join(["%s"] * len(df.columns))
    cursor.executemany(f"INSERT INTO tempo_gols ({cols_sql}) VALUES ({vals_sql})", df.values.tolist())
    conn.commit()
    log.info("âœ…  tempo_gols inserido: %d linha(s) para id_jogo=%s", len(df), id_jogo)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LOOP PRINCIPAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #
for idx, url in enumerate(urls, start=1):
    if not url.strip():
        continue
    if matches_done_with_this_driver >= MAX_MATCHES_PER_DRIVER:
        restart_driver()

    log.info("âš½  (%d/%d) %s", idx, len(urls), url)
    try:
        id_jogo = re.search(r"#id:(\d+)", url).group(1)

        # paÃ­s + odds (resiliente)
        try:
            driver.get(url)
        except TimeoutException:
            log.warning("â±ï¸ page load timeout; tentando novamente 1x")
            restart_driver()
            driver.get(url)
        except WebDriverException as e:
            if "ERR_CONNECTION_RESET" in str(e) and USAR_PROXY:
                desativar_proxy_instavel("ERR_CONNECTION_RESET ao abrir a pÃ¡gina do jogo")
                driver.get(url)
            else:
                raise

        try:
            WebDriverWait(driver, 20).until(
                EC.presence_of_element_located(
                    (By.CSS_SELECTOR,
                     "script[type='application/ld+json'],"
                     "a[href^='/pt/futebol/']:not([href='/pt/futebol/'])")))
        except TimeoutException:
            log.warning("âš ï¸ DOM lento â€” seguindo sem aguardar completamente.")

        pais = get_region_text(driver)
        odd_casa, odd_empate, odd_fora = get_odds(driver)

        # evento
        ev = safe_get_event(id_jogo)
        home_team, away_team = ev["homeTeam"], ev["awayTeam"]
        home = substituicoes_clubes.substituicoes_por_id.get(home_team["id"], home_team["name"].strip())
        away = substituicoes_clubes.substituicoes_por_id.get(away_team["id"], away_team["name"].strip())
        log.info("Partida: %s x %s | odds %s/%s/%s", home, away, odd_casa, odd_empate, odd_fora)

        # INSERT / UPDATE em 'partidas'
        cursor.execute("SELECT pais, odd_casa, odd_empate, odd_fora, campeonato FROM partidas WHERE id_jogo=%s",
                       (id_jogo,))
        row = cursor.fetchone()
        campeonato_padronizado = None

        if not row:
            dt_ini = datetime.datetime.fromtimestamp(ev["startTimestamp"], tz=datetime.timezone.utc)\
                                       .astimezone(datetime.timezone(datetime.timedelta(hours=-3)))
            data_str, hora_str = dt_ini.strftime("%d/%m/%Y"), dt_ini.strftime("%H:%M")
            campeonato_padronizado = substituir_campeonato((ev["tournament"]["name"] or "").split(",")[0])
            round_info = ev.get("roundInfo") or {}
            rodada = re.search(r"\d+", str(round_info.get("name") or round_info.get("round") or "0"))
            rodada = rodada.group() if rodada else "0"
            gols_casa = ev["homeScore"].get("normaltime", ev["homeScore"].get("current", 0))
            gols_fora = ev["awayScore"].get("normaltime", ev["awayScore"].get("current", 0))

            cursor.execute("""
                INSERT INTO partidas
                (id_jogo,data,hora,pais,campeonato,rodada,casa,fora,
                 gols_casa,gols_fora,temporada,odd_casa,odd_empate,odd_fora,cadastrado_em)
                VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)
            """, (id_jogo, data_str, hora_str, pais, campeonato_padronizado, rodada, home, away,
                  gols_casa, gols_fora, temporada, odd_casa, odd_empate, odd_fora,
                  datetime.datetime.now()))
            conn.commit()
            log.info("âœ…  Partida inserida")
        else:
            _, _, _, _, camp_existente = row
            campeonato_padronizado = camp_existente

            sets, vals = [], []
            if pais != "Desconhecido" and not row[0]:
                sets.append("pais=%s");           vals.append(pais)
            if odd_casa and not row[1]:
                sets.append("odd_casa=%s");       vals.append(odd_casa)
            if odd_empate and not row[2]:
                sets.append("odd_empate=%s");     vals.append(odd_empate)
            if odd_fora and not row[3]:
                sets.append("odd_fora=%s");       vals.append(odd_fora)
            if not campeonato_padronizado:
                campeonato_padronizado = substituir_campeonato((ev["tournament"]["name"] or "").split(",")[0])
                sets.append("campeonato=%s");     vals.append(campeonato_padronizado)
            if sets:
                vals.append(id_jogo)
                cursor.execute(f"UPDATE partidas SET {', '.join(sets)} WHERE id_jogo=%s", vals)
                conn.commit()
                log.info("âœ…  Partida atualizada")

        # estatÃ­sticas (blindado)
        try:
            stats = obter_dados_api(f"https://api.sofascore.com/api/v1/event/{id_jogo}/statistics")
            inserir_estatisticas(id_jogo, home, away, "1ST", "1_tempo", stats)
            inserir_estatisticas(id_jogo, home, away, "2ND", "2_tempo", stats)
            inserir_estatisticas(id_jogo, home, away, "ALL", "estatisticas_partidas", stats)
        except Exception as e:
            log.warning("âš ï¸  NÃ£o consegui estatÃ­sticas (%s). Seguindo.", e)

        # jogadores (sem 'mando', blindado)
        try:
            cursor.execute("SELECT 1 FROM estatisticas_jogadores WHERE id_jogo=%s LIMIT 1", (id_jogo,))
            if not cursor.fetchone():
                lineups = obter_dados_api(f"https://api.sofascore.com/api/v1/event/{id_jogo}/lineups")
                players = []
                for side, team in [("home", home), ("away", away)]:
                    for p in lineups.get(side, {}).get("players", []):
                        ply, st = p.get("player", {}), p.get("statistics", {})
                        rp = {
                            "id_jogo": id_jogo, "team": team, "name": ply.get("name"),
                            "position": ply.get("position"),
                            "jersey_number": int(ply.get("jerseyNumber") or 0),
                            "height": int(ply.get("height") or 0), "player_id": ply.get("id"),
                            "date_of_birth_timestamp": ply.get("dateOfBirthTimestamp"),
                            "country": ply.get("country", {}).get("name"),
                            "value": ply.get("proposedMarketValueRaw", {}).get("value"),
                            "substitute": p.get("substitute"), "captain": p.get("captain"),
                            "rating": st.get("ratingVersions", {}).get("original"),
                        }
                        for k, v in st.items():
                            if k != "ratingVersions":
                                rp[re.sub(r'(?<!^)(?=[A-Z])', '_', k).lower()] = v
                        players.append(rp)
                if players:
                    dfp = pd.DataFrame(players).fillna(0); dfp["temporada"] = temporada
                    cursor.execute("SHOW COLUMNS FROM estatisticas_jogadores")
                    cols_db = {c[0] for c in cursor.fetchall()}
                    for col in cols_db:
                        if col not in dfp.columns and col not in ("id", "mando"):
                            dfp[col] = datetime.datetime.now() if col == "cadastrado_em" else 0
                    dfp = dfp[[c for c in dfp.columns if c in cols_db and c != "mando"]]
                    cols_sql = ",".join(f"`{c}`" for c in dfp.columns)
                    vals_sql = ",".join(["%s"] * len(dfp.columns))
                    cursor.executemany(
                        f"INSERT INTO estatisticas_jogadores ({cols_sql}) VALUES ({vals_sql})",
                        dfp.values.tolist())
                    conn.commit()
                    log.info("âœ…  Jogadores inseridos: %d", len(players))
        except Exception as e:
            log.warning("âš ï¸  NÃ£o consegui lineups (%s). Seguindo.", e)

        # >>> TEMPO DOS GOLS
        try:
            inserir_tempo_gols(id_jogo, campeonato_padronizado, home, away)
        except Exception as e:
            log.warning("âš ï¸  NÃ£o consegui tempo_gols (%s). Seguindo.", e)

    except Exception as e:
        if "Timed out receiving message from renderer" in str(e):
            log.warning("ğŸ§¹ Renderer travou â€” reiniciando driver para recuperar.")
            restart_driver()
        log.error("âŒ  Erro em %s: %s", url, e, exc_info=True)

    matches_done_with_this_driver += 1
    time.sleep(random.uniform(4, 8))

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ENCERRAMENTO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #
try:
    driver.quit()
except Exception:
    pass
try:
    cursor.close()
    conn.close()
except Exception:
    pass
log.info("âœ…âœ…âœ…  Processo finalizado.")
